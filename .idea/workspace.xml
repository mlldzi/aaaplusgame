<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="65ea61e0-bec7-4b1d-b492-5271ae5f3e02" name="Changes" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/game/enemy/enemies_spawning.py" beforeDir="false" afterPath="$PROJECT_DIR$/game/enemy/enemies_spawning.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/game/functions.py" beforeDir="false" afterPath="$PROJECT_DIR$/game/functions.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/game/visual/events.py" beforeDir="false" afterPath="$PROJECT_DIR$/game/visual/events.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/game/visual/stars.py" beforeDir="false" afterPath="$PROJECT_DIR$/game/visual/stars.py" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="LogFilters">
    <option name="FILTER_ERRORS" value="false" />
    <option name="FILTER_WARNINGS" value="false" />
    <option name="FILTER_INFO" value="true" />
    <option name="FILTER_DEBUG" value="true" />
    <option name="CUSTOM_FILTER" />
  </component>
  <component name="MarkdownSettingsMigration">
    <option name="stateVersion" value="1" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;customColor&quot;: &quot;&quot;,
  &quot;associatedIndex&quot;: 8
}</component>
  <component name="ProjectId" id="2ZG0BgQQwyx5tx3d2b8aN8BLqL7" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
    &quot;ignore.virus.scanning.warn.message&quot;: &quot;true&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/Users/tereh/OneDrive/Рабочий стол/vampsurv&quot;,
    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
  }
}</component>
  <component name="RunManager">
    <configuration name="moin" type="PythonConfigurationType" factoryName="Python">
      <module name="aaagame" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="SDK_NAME" value="Python 3.11 (aaagame)" />
      <option name="WORKING_DIRECTORY" value="C:\Users\tereh\OneDrive\Рабочий стол\aaagame" />
      <option name="IS_MODULE_SDK" value="false" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/main.py" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="false" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="65ea61e0-bec7-4b1d-b492-5271ae5f3e02" name="Changes" comment="" />
      <created>1702032984697</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1702032984697</updated>
      <workItem from="1702032986207" duration="5471000" />
      <workItem from="1702080549489" duration="2224000" />
      <workItem from="1702085277374" duration="146000" />
      <workItem from="1702253469013" duration="258000" />
      <workItem from="1702375129626" duration="2689000" />
      <workItem from="1702422178924" duration="1000" />
      <workItem from="1702517227778" duration="64000" />
      <workItem from="1702548988962" duration="1113000" />
      <workItem from="1702685913427" duration="3894000" />
      <workItem from="1702799560983" duration="4241000" />
      <workItem from="1702804491864" duration="27000" />
      <workItem from="1702807213429" duration="388000" />
      <workItem from="1702807913653" duration="198000" />
      <workItem from="1702982249441" duration="11546000" />
      <workItem from="1703026701796" duration="2324000" />
      <workItem from="1703049508345" duration="7170000" />
      <workItem from="1703071642307" duration="6378000" />
      <workItem from="1703123654595" duration="4882000" />
      <workItem from="1703148592747" duration="8973000" />
      <workItem from="1703226734932" duration="10198000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="0bd854">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/game/enemy/enemies_spawning.py" />
                  <option value="$PROJECT_DIR$/game/enemy/enemy.py" />
                  <option value="$PROJECT_DIR$/game/enemy/enemy_types.py" />
                </list>
              </option>
              <option name="id" value="0bd854" />
              <option name="initiateTms" value="1703240570195" />
              <option name="request" value="import pygame&#10;from enemy.enemy_types import EnemyType1, EnemyType2&#10;from functions import get_enemy_stats&#10;&#10;enemies_per_wave = {&#10;    0: 0,&#10;    1: 10,&#10;    2: 16,&#10;    3: 20,&#10;}&#10;&#10;&#10;class EnemySpawning:&#10;    def __init__(self, game_size, enemy_size, enemy_speed, wave_size, enemy_spawn_delay, wave_delay, enemies):&#10;        self.game_size = game_size&#10;        self.enemy_size = enemy_size&#10;        self.enemy_speed = enemy_speed&#10;        self.enemies = enemies&#10;&#10;        self.wave_size = wave_size&#10;        self.enemy_spawn_delay = enemy_spawn_delay&#10;        self.wave_delay = wave_delay&#10;&#10;        self.enemies_spawned = 0&#10;        self.current_wave = 0&#10;        self.enemies_in_wave = enemies_per_wave[self.current_wave]&#10;        self.last_enemy_spawn_time = pygame.time.get_ticks()&#10;        self.last_wave_time = pygame.time.get_ticks()&#10;&#10;        self.center = self.game_size // 2&#10;&#10;    def spawn_enemy(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        for _ in range(count):&#10;            enemy = enemy_type(wave_x, wave_y, size, speed, self.center, self.center)&#10;            self.enemies_spawned += 1&#10;            self.enemies.append(enemy)&#10;&#10;    def spawn_enemy_inversion(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        for _ in range(count):&#10;            enemy = enemy_type(abs(1000 - wave_x), wave_y, size, speed, self.center, self.center)&#10;            self.enemies_spawned += 1&#10;            self.enemies.append(enemy)&#10;&#10;    def spawn_new_enemy(self):&#10;        if self.current_wave == 1:&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 3)&#10;            self.spawn_enemy(EnemyType2, 5)&#10;        elif self.current_wave == 2:&#10;            self.spawn_enemy(EnemyType2, 10)&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 4)&#10;&#10;    def handle_enemy_spawning(self):&#10;        current_time = pygame.time.get_ticks()&#10;        print(self.enemies_spawned, self.enemies_in_wave, len(self.enemies))&#10;        if self.enemies_spawned == 0:&#10;            self.spawn_new_enemy()&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def handle_wave_transition(self):&#10;        current_time = pygame.time.get_ticks()&#10;        if self.enemies_spawned &gt;= self.enemies_in_wave and len(self.enemies) == 0 and current_time - self.last_wave_time &gt; self.wave_delay:&#10;            self.current_wave += 1&#10;            self.enemies_spawned = 0&#10;            self.last_wave_time = current_time&#10;&#10;сделай задержку между появлением врагов в &#10;    def spawn_enemy(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        for _ in range(count):&#10;            enemy = enemy_type(wave_x, wave_y, size, speed, self.center, self.center)&#10;            self.enemies_spawned += 1&#10;            self.enemies.append(enemy)&#10;&#10;    def spawn_enemy_inversion(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        for _ in range(count):&#10;            enemy = enemy_type(abs(1000 - wave_x), wave_y, size, speed, self.center, self.center)&#10;            self.enemies_spawned += 1&#10;            self.enemies.append(enemy)" />
              <option name="response" value="" />
              <option name="responseDescription" value="It seems like you want to add a delay between enemy spawns in the `EnemySpawning` class. To achieve this, you can modify the `spawn_enemy` and `spawn_enemy_inversion` methods. Here's the updated code:&#10;&#10;```python&#10;import pygame&#10;from enemy.enemy_types import EnemyType1, EnemyType2&#10;from functions import get_enemy_stats&#10;&#10;enemies_per_wave = {&#10;    0: 0,&#10;    1: 10,&#10;    2: 16,&#10;    3: 20,&#10;}&#10;&#10;&#10;class EnemySpawning:&#10;    def __init__(self, game_size, enemy_size, enemy_speed, wave_size, enemy_spawn_delay, wave_delay, enemies):&#10;        self.game_size = game_size&#10;        self.enemy_size = enemy_size&#10;        self.enemy_speed = enemy_speed&#10;        self.enemies = enemies&#10;&#10;        self.wave_size = wave_size&#10;        self.enemy_spawn_delay = enemy_spawn_delay&#10;        self.wave_delay = wave_delay&#10;&#10;        self.enemies_spawned = 0&#10;        self.current_wave = 0&#10;        self.enemies_in_wave = enemies_per_wave[self.current_wave]&#10;        self.last_enemy_spawn_time = pygame.time.get_ticks()&#10;        self.last_wave_time = pygame.time.get_ticks()&#10;&#10;        self.center = self.game_size // 2&#10;&#10;    def spawn_enemy(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        current_time = pygame.time.get_ticks()&#10;        if current_time - self.last_enemy_spawn_time &gt;= self.enemy_spawn_delay:&#10;            for _ in range(count):&#10;                enemy = enemy_type(wave_x, wave_y, size, speed, self.center, self.center)&#10;                self.enemies_spawned += 1&#10;                self.enemies.append(enemy)&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def spawn_enemy_inversion(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        current_time = pygame.time.get_ticks()&#10;        if current_time - self.last_enemy_spawn_time &gt;= self.enemy_spawn_delay:&#10;            for _ in range(count):&#10;                enemy = enemy_type(abs(1000 - wave_x), wave_y, size, speed, self.center, self.center)&#10;                self.enemies_spawned += 1&#10;                self.enemies.append(enemy)&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def spawn_new_enemy(self):&#10;        if self.current_wave == 1:&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 3)&#10;            self.spawn_enemy(EnemyType2, 5)&#10;        elif self.current_wave == 2:&#10;            self.spawn_enemy(EnemyType2, 10)&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 4)&#10;&#10;    def handle_enemy_spawning(self):&#10;        current_time = pygame.time.get_ticks()&#10;        print(self.enemies_spawned, self.enemies_in_wave, len(self.enemies))&#10;        if self.enemies_spawned == 0:&#10;            self.spawn_new_enemy()&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def handle_wave_transition(self):&#10;        current_time = pygame.time.get_ticks()&#10;        if self.enemies_spawned &gt;= self.enemies_in_wave and len(self.enemies) == 0 and current_time - self.last_wave_time &gt; self.wave_delay:&#10;            self.current_wave += 1&#10;            self.enemies_spawned = 0&#10;            self.last_wave_time = current_time&#10;```&#10;&#10;I added a check in both `spawn_enemy` and `spawn_enemy_inversion` methods to compare the current time with the last enemy spawn time. If the difference is greater than or equal to the `enemy_spawn_delay`, a new enemy will be spawned. This ensures that there is a delay between enemy spawns." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1703240582628" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/game/enemy/enemies_spawning.py" />
                  <option value="$PROJECT_DIR$/game/enemy/enemy.py" />
                  <option value="$PROJECT_DIR$/game/enemy/enemy_types.py" />
                  <option value="$PROJECT_DIR$/game/functions.py" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="c39946">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/game/enemy/enemies_spawning.py" />
                </list>
              </option>
              <option name="id" value="c39946" />
              <option name="initiateTms" value="1703240636361" />
              <option name="request" value="враги вообще не появлвются" />
              <option name="response" value="" />
              <option name="responseDescription" value="I apologize for the oversight. It seems that the `handle_enemy_spawning` method is not being called to initiate the enemy spawning process. To fix this, you need to call the `handle_enemy_spawning` method at the appropriate place in your code. Here's the updated code:&#10;&#10;```python&#10;import pygame&#10;from enemy.enemy_types import EnemyType1, EnemyType2&#10;from functions import get_enemy_stats&#10;&#10;enemies_per_wave = {&#10;    0: 0,&#10;    1: 10,&#10;    2: 16,&#10;    3: 20,&#10;}&#10;&#10;&#10;class EnemySpawning:&#10;    def __init__(self, game_size, enemy_size, enemy_speed, wave_size, enemy_spawn_delay, wave_delay, enemies):&#10;        self.game_size = game_size&#10;        self.enemy_size = enemy_size&#10;        self.enemy_speed = enemy_speed&#10;        self.enemies = enemies&#10;&#10;        self.wave_size = wave_size&#10;        self.enemy_spawn_delay = enemy_spawn_delay&#10;        self.wave_delay = wave_delay&#10;&#10;        self.enemies_spawned = 0&#10;        self.current_wave = 0&#10;        self.enemies_in_wave = enemies_per_wave[self.current_wave]&#10;        self.last_enemy_spawn_time = pygame.time.get_ticks()&#10;        self.last_wave_time = pygame.time.get_ticks()&#10;&#10;        self.center = self.game_size // 2&#10;&#10;    def spawn_enemy(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        current_time = pygame.time.get_ticks()&#10;        if current_time - self.last_enemy_spawn_time &gt;= self.enemy_spawn_delay:&#10;            for _ in range(count):&#10;                enemy = enemy_type(wave_x, wave_y, size, speed, self.center, self.center)&#10;                self.enemies_spawned += 1&#10;                self.enemies.append(enemy)&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def spawn_enemy_inversion(self, enemy_type, count=1):&#10;        wave_x, wave_y, size, speed = get_enemy_stats(enemy_type)&#10;        current_time = pygame.time.get_ticks()&#10;        if current_time - self.last_enemy_spawn_time &gt;= self.enemy_spawn_delay:&#10;            for _ in range(count):&#10;                enemy = enemy_type(abs(1000 - wave_x), wave_y, size, speed, self.center, self.center)&#10;                self.enemies_spawned += 1&#10;                self.enemies.append(enemy)&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def spawn_new_enemy(self):&#10;        if self.current_wave == 1:&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 3)&#10;            self.spawn_enemy(EnemyType2, 5)&#10;        elif self.current_wave == 2:&#10;            self.spawn_enemy(EnemyType2, 10)&#10;            self.spawn_enemy(EnemyType1, 2)&#10;            self.spawn_enemy_inversion(EnemyType1, 4)&#10;&#10;    def handle_enemy_spawning(self):&#10;        current_time = pygame.time.get_ticks()&#10;        print(self.enemies_spawned, self.enemies_in_wave, len(self.enemies))&#10;        if self.enemies_spawned == 0:&#10;            self.spawn_new_enemy()&#10;            self.last_enemy_spawn_time = current_time&#10;&#10;    def handle_wave_transition(self):&#10;        current_time = pygame.time.get_ticks()&#10;        if self.enemies_spawned &gt;= self.enemies_in_wave and len(self.enemies) == 0 and current_time - self.last_wave_time &gt; self.wave_delay:&#10;            self.current_wave += 1&#10;            self.enemies_spawned = 0&#10;            self.last_wave_time = current_time&#10;&#10;# Create an instance of EnemySpawning and call handle_enemy_spawning&#10;enemy_spawning = EnemySpawning(game_size, enemy_size, enemy_speed, wave_size, enemy_spawn_delay, wave_delay, enemies)&#10;enemy_spawning.handle_enemy_spawning()&#10;```&#10;&#10;Make sure to replace `game_size`, `enemy_size`, `enemy_speed`, `wave_size`, `enemy_spawn_delay`, `wave_delay`, and `enemies` with the appropriate values in the `EnemySpawning` instance creation. This will ensure that the `handle_enemy_spawning` method is called and the enemies start spawning." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1703240648258" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/game/enemy/enemies_spawning.py" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
  <component name="com.intellij.coverage.CoverageDataManagerImpl">
    <SUITE FILE_PATH="coverage/aaagame$events.coverage" NAME="events Coverage Results" MODIFIED="1702037928716" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game/visual" />
    <SUITE FILE_PATH="coverage/aaagame$enemies_handler.coverage" NAME="enemies_handler Coverage Results" MODIFIED="1702038034989" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game/enemy" />
    <SUITE FILE_PATH="coverage/aaagame$moin.coverage" NAME="moin Coverage Results" MODIFIED="1702802880362" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="C:\Users\tereh\OneDrive\Рабочий стол\aaagame" />
    <SUITE FILE_PATH="coverage/main_py$main.coverage" NAME="main Coverage Results" MODIFIED="1702807536326" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/../Vampire_survivors-main" />
    <SUITE FILE_PATH="coverage/aaagame$player.coverage" NAME="player Coverage Results" MODIFIED="1702036455161" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game" />
    <SUITE FILE_PATH="coverage/aaagame$main.coverage" NAME="main Coverage Results" MODIFIED="1702082233214" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
    <SUITE FILE_PATH="coverage/aaagame$game.coverage" NAME="game Coverage Results" MODIFIED="1702035795813" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game" />
    <SUITE FILE_PATH="coverage/aaagame$enemies_spawning.coverage" NAME="enemies_spawning Coverage Results" MODIFIED="1702081629000" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game/enemy" />
    <SUITE FILE_PATH="coverage/main_py$moin.coverage" NAME="moin Coverage Results" MODIFIED="1703241635618" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="C:\Users\tereh\OneDrive\Рабочий стол\aaagame" />
    <SUITE FILE_PATH="coverage/aaagame$button_events.coverage" NAME="button_events Coverage Results" MODIFIED="1702033983930" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game" />
    <SUITE FILE_PATH="coverage/aaagame$render.coverage" NAME="render Coverage Results" MODIFIED="1702033575684" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/game" />
  </component>
</project>